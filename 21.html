<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="source/favicon.ico" type="image/x-icon">
    <title>Уроки | University 2.0</title>
    <link rel="stylesheet" href="source/main.css">
    <link rel="stylesheet" href="source/style.css">

    <link rel="stylesheet" href="source/tikets.css">
    <link rel="stylesheet" href="source/profile_window.css">

    <link rel='stylesheet' href="source/default.css">
    <link rel='stylesheet' href="source/idea.css">
    <script type="text/javascript" src="source/highlight.pack.js"></script>
</head>
<body>


    <div id="myfond_gris" opendiv=""></div>
    <div align="center" style="padding-top:35px;">
        <div id="box_1" class="mymagicoverbox_fenetre" style="left:-225px; width:450px;">
            Anon | 00500
            <div class="mymagicoverbox_fenetreinterieur" style="height:220px; ">
                <div align="left">
                    <p class="lead">Имя пользователя: Anon</p>
                    <p class="lead">Статус: Активен</p>
                    <p class="lead">Регистрация jabber: <a target="_blank" href="http://plast.cash/registration.php?key="></a></p>
                    <p class="lead">Поток: Anon</p>
                    <p class="lead">TG канал: <a target="_blank" href="">Канал для опретивных оповещений</a></p>
                    
                    <br><br>
                    <div style="width:100px" align="center" class="mymagicoverbox_fermer">Закрыть</div>
                </div>
            </div>
        </div>
    </div>



<div class="main_container">
    <header>
        <a href="index.html"><img class="logo" src="source/logo.png" alt="University 2.0"></a>
        <div class="header_right">
            <div class="user_info">
                <p>Hello,
                <a href="#" iddiv="box_1" class="mymagicoverbox"> Anon </a>


                </p>
                <p>ID: 00500</p>
            </div>
            <div class="user_actions">
                <a href="help.html"
                   class="btn btn_gray btn_transparent btn_border_transparent btn_icon btn_icon_help">Помощь</a>
                
                    
                    <a href="index.html" class="btn  btn_round btn_status btn_status_active btn_gray btn_exit">Выход</a>
                
            </div>
        </div>
    </header>
    <div class="container">
        <nav>
            <a href="index.html" class="btn btn_icon btn_icon_dashboard ">Сводка</a>
            <a href="lections.html" class="btn btn_icon btn_icon_book active">Лекции</a>
            <a href="index.html" class="btn btn_icon btn_icon_group ">Тикеты</a>
            <a href="faq.html" class="btn btn_icon btn_icon_chat ">FAQ</a>
        </nav>
        <div class="content">

<a href="hack.html">       
    <div class="banner_block" style="background-image:url('source/hack_9X2ouwy.jpg')">
        <div class="banner_content">
            <h2>Хак</h2>
            <p>Лучшая защита - это нападение.</p>
        </div>
    </div>
    </a>
    <br>

            

            
    <div class="article_actions">
        <a href="hack.html" class="btn btn_round btn_gray  btn_icon btn_icon_back ">Назад</a>
    </div>


<div class="text_content">
        <p>Файлы для операционной системы Linux - это просто поток байтов. Эта концепция также распространяется на физические устройства, что упрощает обмен и хранение данных. Как я уже говорил, первый бит прав доступа указывает на тип файла и что типов этих даже не 2.</p>

<ol>
    <li>Файлы физических устройств.</li>
    <li>PIPE - файлы межпроцесного взаимодействия.</li>
    <li>Sockets - Сокеты.</li>
    <li>Simlinks - символические ссылки.</li>
</ol>

<p>1. Файлы физических устройств.</p>

<p>Как уже говорилось, с точки зрения ОС Linux, все подключаемые к компьютеру устройства (жесткие и съемные диски, терминал, принтер, модем и т. д.), представляются файлами.&nbsp;Файлы физ. устройств храняться в системном каталоге &quot;<tt>/dev</tt>&quot;. Если, например, надо вывести на экран какую-то информацию, то система как бы производит запись в файл /dev/tty01.</p>

<p>2. PIPE.</p>

<p>Еще один тип специальных файлов&nbsp;&mdash; именованные каналы, или буферы FIFO (First In&nbsp;&mdash; First Out). Файлы этого типа служат в основном для того, чтобы организовать обмен данными между разными приложениями (pipe переводится с английского как труба).</p>

<p>3. Sockets.</p>

<p>Гнезда&nbsp;&mdash; это соединения между процессами, которые позволяют им взаимодействовать, не подвергаясь влиянию других процессов. Вообще сокеты (и взаимодействие программ при помощи сокетов) играют очень важную роль во всех Unix-системах, включая и Linux: они являются ключевым понятием TCP/IP и соответственно на них целиком строится Интернет. Однако с точки зрения файловой системы сокеты практически неотличимы от именованных каналов: это просто метки, позволяющие связать несколько программ. После того как связь установлена, общение программ происходит без участия файла гнезда: данные передаются ядром ОС непосредственно от одной программы к другой.</p>

<p>4. Simlinks.</p>

<p>Ссылки бывают двух видов: жесткие и символические.</p>

<p>Жесткие ссылки просто еще одно имя для исходного файла. Она прописывается в индексном дескрипторе исходного файла. После создания жесткой ссылки невозможно различить, где исходное имя файла, а где ссылка. Если удалить один из этих файлов (точнее одно из этих имен), то файл еще сохраняется на диске (пока у него есть хоть одно имя-ссылка). Особенностью жестких ссылок является то, что они прямо указывают на номер индексного дескриптора, а, следовательно, такие имена могут указывать только на файлы внутри той же самой файловой системы (<strong><em>ФС</em></strong>) (<em>т.&nbsp;е. на том же самом носителе, на котором находится каталог, содержащий это имя</em>).</p>

<p>Символические ссылки тоже могут рассматриваться как дополнительные имена файлов, но в то же время они представляются отдельными файлами&nbsp;&mdash; файлами типа символических ссылок. В отличие от жестких ссылок символические ссылки могут указывать на файлы и директории, расположенные в другой файловой системе, например, на монтируемом носителе, или даже на другом компьютере. Если исходный файл удален, символическая ссылка не удаляется, но становится бесполезной.</p>

<p>Первые 3 типа файлов создаются ОС или процессами, мы можем создавать для себя ссылки на файлы. Делается это с помошью команды &quot;<tt>ln [OPTIONS] [TARGET] [LINK NAME]</tt>&quot;. Например у меня, из-за локали, в домашней директории лежат каталоги с русскими именами (Загрузки, Документы, etc) и мне удобно делать символические ссылки на эти каталоги с английскими именами, чтобы не переключать раскладку при навигации. Можешь попробовать создать символьную ссылку на директорию &quot;<tt>/var/log</tt>&quot; в свой домашний каталог. Символические ссылки создаются ключем &quot;<tt>-s</tt>&quot;, жесткие - без опций.</p>

<p><img alt="" src="source/ln_s.gif" style="height:449px; width:100%" /></p>

<p>Если удалить каталог &quot;<tt>/tmp/perms/log</tt>&quot; то удалится &quot;<tt>/var/log</tt>&quot;, для удаления ссылок существует команда &quot;<tt>unlink [LINK_NAME]</tt>&quot;.</p>

<p>Если ты создал в каталоге &quot;<tt>dir1</tt>&quot; символическую ссылку, которая указывает на какой-то другой каталог, то можешь переместить каталог &quot;<tt>dir1</tt>&quot; куда угодно, символическая ссылка при этом будет оставаться корректной. Точно так же можно перемещать сами символические ссылки. И осторожно с относительными путями, например: использование &quot;<tt>..</tt>&quot; (это ссылка на родительский каталог) в полных именах файлов, включающих символические ссылки, поскольку по символической ссылке нельзя проследовать в обратном направлении, а &quot;<tt>..</tt>&quot; всегда означает истинный родительский каталог данного каталога.</p>

<p>Теперь более подробно расскажу о работе с файлами на физических устройствах.</p>

<h2><strong>Создание директорий</strong></h2>

<p>Начнем с создания директорий. Команда &quot;mkdir [OPTIONS] [PATH]&quot; создаст директорию по указанному пути если путь не занят. Опция &quot;<tt>-m</tt>&quot; задает режим доступа для новой директории, а &quot;<tt>-p</tt>&quot; создаст промежуточные директории (такой подход еще называют рекурсивным). Пример созддания директории &quot;tmp&quot; в домашней папке:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ mkdir -m 700 tmp</tt></div>

<p><span style="color:#999999">Правила указания путей действуют везде и всегда.</span></p>

<h2><strong>Создание Файлов</strong></h2>

<p>Создать файл можно несколькими способами:</p>

<h3>1. cat</h3>

<p>Команда &quot;cat&quot; не делает ничего кроме вывода содержимого файла, а создавать файлы можно благодаря перенаправлению вывода этой команды (подробнее об этом позже). Еще кат умеет объединять вывод (конкатенация) нескольких файлов. Таким образом можно создать файл так:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ cat file1 file2 &gt; file</tt></div>

<p>И содержимое &quot;<tt>file1</tt>&quot; и &quot;<tt>file2</tt>&quot; будет записано в файл &quot;<tt>file</tt>&quot;. Также можно сделать такой трюк</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ cat &gt; file</tt></div>

<p>И написать какой то текст, после чего нажать комбинацию &quot;<tt>Ctrl+C</tt>&quot; (<em>Используется для прерывания работы в терминале</em>) и все что ты введешь, будет записано в файл &quot;<tt>file</tt>&quot;.</p>

<blockquote>
<p>Есть еще команда &quot;<tt>tac</tt>&quot;, которая делает тоже самое, только с реверсом строк на выводе.</p>
</blockquote>

<h3>2. echo</h3>

<p>Ехо, также как и кат, просто перенаправляет вывод, отправляет на стандартный поток вывода, то что было передано как параметр. Например:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ echo &quot;hello world&quot; &gt; test.txt</tt></div>

<p>Еще:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ echo &quot;line1\nline2&quot;</tt></div>

<p>И еще:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ echo $(which sh)</tt></div>

<h3>3. touch</h3>

<p>Touch утилита серьезнее и мы о ней еще будем говорить. Создать файл с помощью touch просто:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ touch file</tt></div>

<p>Файл будет пустым.</p>

<h3>4. Nano</h3>

<p><tt>nano</tt> - это уже консольный текстовый редактор. Он легкий, все шоткаты описаны внизу (символ &quot;<tt>^</tt>&quot; означает &lt;<tt>Ctrl</tt>&gt;).</p>

<p><img alt="" src="source/nano.gif" style="height:449px; width:100%" /></p>

<h2><strong>Копирование и перемещение</strong></h2>

<p>Для копирования файлов и папок используется команда &quot;cp [OPTIONS] [SOURCE] [DESTINATION]&quot;, при этом есть 2 варианта (если копируются папки): копирование только содержимого в существующий каталог и копирование каталога с содержимым. Опции для команды такие:</p>

<ul>
    <li>-p - сохранить время модификации файла и максимально возможные полномочия (без этой опции для нового файла задаются права, соответствующие правам запустившего команду пользователя).</li>
    <li>-R или -r - рекурсивное копирование.</li>
    <li>-d - если задать эту опцию, то символические ссылки будут оставаться ссылками (а иначе вместо ссылки копируется файл, на который дается ссылка).</li>
    <li>-f - перезаписать существующие в DESTINATION файлы&nbsp; без дополнительных предупреждений.</li>
</ul>

<p>Когда копируется директория всегда указывай ключ &quot;<tt>-r</tt>&quot;, если копируется содержимое директории и нужно скопировать только файлы, то ключ &quot;<tt>-r</tt>&quot; не нужен.</p>

<p><img alt="" src="source/cp_file_replace.gif" style="height:449px; width:100%" /><img alt="" src="source/cp_file.gif" style="height:449px; width:100%" /></p>

<p><img alt="" src="source/cp_dir.gif" style="height:449px; width:100%" /></p>

<p>Для перемещения файлов используется команда &quot;<tt>mv</tt>&quot;, ее же используют для переименования. Синтаксис тот же, а вот порядок указания путей для mv другой, не поддерживаются маски (*.txt например).</p>

<h2><strong>Удаление файлов и папок</strong></h2>

<p>Команда &quot;rm&quot; используется для удаления файловых объектов. Синтаксис следующий &quot;rm [OPTIONS] [PATH]&quot;. В качесве опций крайне рекомендую всегда использовать &quot;-i&quot;. Эта опция будет требовать дополнительного подтверждения. Еще есть опция &quot;-r&quot; для рекунсивного удаления директории. Опасная штука, так как удаляет жестко и можно убить систему например так:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ rm -rf /*</tt></div>

<p>Будет удалять все, что может удалить пользователь. Ключ &quot;<tt>-f</tt>&quot; нужен чтобы игнорировать несуществующие файлы и аргументы, ни о чем не спрашивать. Запуск от рута убьет систему, без - поколечит.</p>

<h2><strong>Чтение файлов</strong></h2>

<p>Для чтения больших файлов (например файлов документации) используйте команды &quot;<tt>more</tt>&quot;&nbsp; и &quot;<tt>less</tt>&quot;. Команда-фильтр &quot;more&quot; выводит содержимое файла на экран отдельными страницами, размером как раз в целый экран. Для того, чтобы увидеть следующую страницу, надо нажать на клавишу пробела. Нажатие на клавишу &lt;Enter&gt; приводит к смещению на одну строку. Кроме клавиш пробела и &lt;Enter&gt; в режиме паузы еще некоторые клавиши действуют как управляющие (например, клавиша &lt;B&gt; возвращает вас на один экран назад), но я не буду приводить полного их перечня, как и перечня опций команды. Тебе для начала надо еще только запомнить, что выйти из режима просмотра можно с помощью клавиши &lt;Q&gt;, так как если ты этого не знаешь, то тебе придется долго и нудно нажимать пробел, пока вы не доберешься до конца длинного файла. Обо всех опциях команды &quot;<tt>more</tt>&quot; можно прочитать в интерактивном руководстве man.</p>

<p>Утилита &quot;<tt>less</tt>&quot;, разработанная в рамках проекта GNU, содержит все функции и команды управления выводом, имеющиеся в программе &quot;<tt>more</tt>&quot;, и некоторые дополнительные, например, позволяет использовать клавиши управления курсором (&lt;Стрелка вверх&gt;, &lt;Стрелка вниз&gt;, &lt;PgUp&gt;, &lt;PgDown&gt;) для перемещения по тексту.</p>

<p>Команды &quot;<tt>more</tt>&quot; и &quot;<tt>less</tt>&quot; позволяют производить поиск подстроки в просматриваемом файле, причем команда &quot;<tt>less</tt><strong>&quot; </strong>позволяет производить поиск как в прямом, так и в обратном направлении. Для организации поиска строки символов &#39;string&#39; надо набрать в командной строке программы в нижней части экрана (<em>там, где двоеточие</em>) &#39;<tt>/string</tt>&#39;. Если искомая строка будет найдена, будет отображен соответствующий кусок текста, причем найденная строка будет находиться в самом верху экрана.</p>

<h2><strong>Поиск файлов</strong></h2>

<p>Команда find может искать файлы по имени, размеру, дате создания или модификации и некоторым другим критериям. Общий синтаксис команды &quot;<tt>find</tt>&quot; имеет следующий вид: &quot;<tt>find [PATH1..PATHN] [OPTIONS]</tt> [ACTION]&quot;. Список путей для поиска разделяется пробелом, опции описывают критерии поиска, а последним параметром описывается действие которое нужно применить к каждому найденому файлу.</p>

<p>При поиске можно пользоваться шаблонами (масками). Чаще всего маски файлов строятся с помощью специальных символов &quot;*&quot; и &quot;?&quot;. Символ &quot;*&quot; используется для замены произвольной строки символов.</p>

<ul>
    <li>
    <p>&quot;<tt>*</tt>&quot;&nbsp;&mdash; соответствует всем файлам, за исключением скрытых;</p>
    </li>
    <li>
    <p>&quot;<tt>.*</tt>&quot;&nbsp;&mdash; соответствует всем скрытым файлам (но также текущему каталогу &quot;<tt>.</tt>&quot; и каталогу уровнем выше &quot;<tt>..</tt>&quot;: не забывайте об этом!);</p>
    </li>
    <li>
    <p>&quot;<tt>*.*</tt>&quot;&nbsp;&mdash; соответствует только тем файлам и каталогам, которые имеют &quot;<tt>.</tt>&quot; в середине имени, или оканчиваются на точку;</p>
    </li>
    <li>
    <p>&quot;<tt>p*r</tt>&quot;&nbsp;&mdash; соответствует и &quot;peter&quot; и &quot;piper&quot;;</p>
    </li>
    <li>
    <p>&quot;<tt>*c*</tt>&quot;&nbsp;&mdash; соответствует и &quot;picked&quot; и &quot;peck&quot;.</p>
    </li>
</ul>

<p>Символ &quot;<tt>?</tt>&quot; заменяет один произвольный символ, поэтому index?.htm будет соответствовать именам index0.htm, index5.htm и indexa.htm.</p>

<p>Кроме &quot;<tt>*</tt>&quot; и &quot;<tt>?</tt>&quot; в Linux при задании шаблонов имен можно использовать квадратные скобки [], в которых дается либо список возможных символов, либо интервал, в который должны попадать возможные символы. Например, &quot;<tt>[abc]*</tt>&quot; соответствует всем именам файлов, начинающимся с a, b, c или &quot;<tt>*[I-N1-3]</tt>&quot; соответствует файлам, имена которых оканчиваются на I, J, K, L, M, N, 1, 2, 3.</p>

<p>Основные критерии поиска find:</p>

<ul>
    <li><tt>-name</tt> <em>mask</em> - имя файла</li>
    <li><tt>-path</tt> <em>mask</em> - абсолютное имя файла (это значит, /path/to/file/filename.ext).</li>
    <li><tt>-group</tt> <em>str</em> - поиск по группе.</li>
    <li><tt>-size</tt> <em>int</em>[<tt>c</tt>] - поиск по размеру файла, если указано &quot;c&quot; значит размер в байтах.</li>
    <li><tt>-mtime</tt> <em>int</em> - поиск файлов измненных int дней назад.</li>
    <li><tt>-newer</tt> <em>file</em> - файлы кторые изменялись после &quot;file&quot;.</li>
    <li><tt>-type</tt> <em>chr</em> - поиск по типу</li>
</ul>

<p>mask - маска поиска, str - текст (строка), int - число, chr - буква. Для поиска по группе надо написать строковое представление группы, размер указывается десятичным числом, а вот в качестве типа можно указать одно из:</p>

<ul>
    <li><tt>b - <em>блок-ориентированные устройства</em></tt></li>
    <li><tt>c - <em>байт-ориентированные устройства</em></tt></li>
    <li><tt>d - <em>директория</em></tt></li>
    <li><tt>f <em>- обычный файл</em></tt></li>
    <li><tt>p <em>- именованный канал</em></tt></li>
    <li><tt>l <em>- символическая ссылка</em></tt></li>
</ul>

<p>Поиск с помощью &quot;find&quot; всегда рекурсивный. Например так можно найти все txt файлы в текущем каталоге и в под каталогах:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ find ./ -name &quot;*.txt&quot; -type f -print</tt></div>

<p>Или удалить в текущем каталоге все файлы, к которым пользователи не обращались в течение 30 дней:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ find . -type f -atime +30 -exec rm -i {} \;</tt></div>

<h2><strong>Разбить файл на части</strong></h2>

<p>Если будет необходимо разбить файл на части, то можно использовать утилиту &quot;<tt>split</tt>&quot;. Указать нужно 3 параметра: &quot;-b&quot; размер части и k (килобайты), m (мегабайты) по умолчанию размер в байтах; название вхоного файла; префикс для кусков.</p>

<p>Например:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ split -b1m process.bin chank.</tt></div>

<p>Теперь можно перенести куски (chank.aa, chank.ab, chank.ac, chank.ad, chank.ae) и собрать обратно:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ cat chank.* &gt; process.bin</tt></div>

<p>Еще можно разбить файл по кол-ву строк:</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ split -l 1 myfile.txt part.</tt></div>

<h2><strong>Сравнение файлов</strong></h2>

<p>Сравнивать файлы можно с помощью &quot;cmp&quot; который просто сообщит о наличии изменений или с помощью &quot;diff&quot; который выведит список этих изменений.</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ cmp file_old file_new</tt></div>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ diff file_old file_new</tt></div>

<p>К примеру ты написал скрипт и раздал его друзьям. Позже ты переписал часть кода, улучшив функционал. Теперь перед тобой возникает вопорос распространить обновление. Как записать изменения в файл ты уже догадался. А вот применить эти изменения может команда &quot;<tt>patch</tt>&quot;.</p>

<div style="background:#eeeeee; border:1px solid #cccccc; padding:5px 10px"><tt>$ patch original diff &gt; new</tt></div>

<p>&nbsp;</p>
    </div>
    <br>
 
        </div>
    </div>
</div>
<footer>
    <p>University 2.0</p>
</footer>

</body>
</html>